এই কোর্সের প্রথমে আমরা শিখেছি কীভাবে `docker run` কম্যান্ড ব্যবহার করে একটি ডকার কনটেইনার রান করতে হয়। কিন্তু যদি আমরা একটি কমপ্লেক্স অ্যাপলিকেশন গঠণ করতে চাই যেটা অনেকগুলো সার্ভিস রান করে সেক্ষেত্রে একটি ভালো উপায় হচ্ছে `docker compose` ব্যবহার করা। `docker compose` কম্যান্ড ব্যবহার করে আমরা `yml` ফরম্যাটে একটি কনফিগারেশন ফাইল (`docker-compose.yml`) তৈরি করতে পারি এবং বিভিন্ন সার্ভিস ও তাদের বিভিন্ন অপশনগুলোকে রান করার জন্যে এই ফাইলে একত্রে রাখতে পারি। এরপর আমরা `docker-compose up` কম্যান্ড ব্যবহার করে পুরো অ্যাপলিকেশনটি রান করতে পারি। 

![](Screenshot%20from%202022-05-14%2019-48-57.png)

এটা ইমপ্লিমেন্ট করা, রান করা এবং মেইনটেইন করা সহজ কারণ সব পরিবর্তনগুলো ডকার কম্পোজ কনফিগারেশন ফাইলের (docker-compose.yml) মধ্যেই সীমাবদ্ধ থাকে। যাই হোক, এটি শুধু সিঙ্গেল ডকার হোস্টে কনটেইনারসমূহ রান করার জন্য প্রযোজ্য। এখন আমরা একটি ভালো উদাহরণ দেখি। 

নিম্নের অ্যাপলিকেশনটি ডকার দ্বারা তৈরি একটি সাধারণ কিন্তু বিস্তীর্ণ  অ্যাপলিকেশন যেটার মাধ্যমে আমরা একটি অ্যাপলিকেশন স্ট্যাক রান করার জন্যে ডকারের বিভিন্ন ফিচার সম্পর্কে জানবো। 

![](Screenshot%20from%202022-05-14%2019-49-28.png)

প্রথমে আমরা অ্যাপলিকেশনটির সাথে পরিচিত হয়ে নিই। 
এটি একটি ভোটিং অ্যাপলিকেশন যেটা ইউজারদের ভোট প্রদানের জন্যে একটি ইন্টারফেচ এবং ভোটের ফলাফল দেখানোর জন্যে একটি ইন্টারফেচ সরবরাহ করে। অ্যাপলিকেশনটি বিভিন্ন উপাদান নিয়ে তৈরি। যেমন : একটি ভোটিং অ্যাপ (পাইথন ব্যবহার করে তৈরি একটা ওয়েব অ্যাপলিকেশন) যেটা ইউজারদের দুটি অপশনের মধ্যে একটি পছন্দ করার (cats, dogs) জন্য ইন্টারফেচ প্রদান করে। 

![](Screenshot%20from%202022-05-14%2019-50-12.png)

যখন ইউজার একটি অপশন বেছে নেয় তখন তা redis-এ জমা হয়। `redis` মেমোরিতে একটি ডাটাবেজ হিসেবে কাজ করে। তারপর এই ভোট প্রসেস করে worker। worker হলো .net -এ লেখা একটা অ্যাপলিকেশন। worker নতুন ভোট নিয়ে persistent ডাটাবেজ আপডেট করে (এক্ষেত্রে সেটা PostgresSQL)। PostgresSQL-এ শুধুমাত্র প্রত্যেক ক্যাটাগরির ভোটসংখ্যাযুক্ত (এক্ষেত্রে শুধু cats আর dogs) একটি টেবিল থাকে। এখানে cats-এ ভোট পরায় cats-এর ভোটসংখ্যা এক বৃদ্ধি পায়। 

![](Screenshot%20from%202022-05-14%2019-51-00.png)

সবশেষে ভোটের ফলাফল আর একটি ইন্টারফেচে প্রদর্শিত হয় যেটা nodeJS দ্বারা তৈরি একটি ওয়েব অ্যাপলিকেশন। এই অ্যাপলিকেশনটি PostgresSQL ডাটাবেজ থেকে ভোটসংখ্যা নিয়ে তা ইউজারকে প্রদর্শন করে। 

![](Screenshot%20from%202022-05-14%2019-51-34.png)

এটাই হলো পুরো voting অ্যাপলিকেশন স্ট্যাকটির আর্কিটেকচার এবং ডাটা ফ্লো। এই অ্যাপলিকেশন স্ট্যাকটি বিভিন্ন সার্ভিস, বিভিন্ন ডেভেলপমেন্ট টুলস এবং বিভিন্ন ডেভেলপমেন্ট প্ল্যাটফের্মের (python, .net, NodeJS) কম্বিনেশনে তৈরি হয়েছে। এখন আমরা দেখবো কীভাবে একটি সিঙ্গেল ডকার ইঞ্জিনে এই অ্যাপলিকেশন স্ট্যাকটি তৈরি করা যায় (প্রথমে docker run কম্যান্ড ব্যবহার করে এবং পরবর্তীতে docker compose কম্যান্ড ব্যবহার করে)। এক্ষেত্রে আমরা ধরে নিব সকল ইমেজ বিল্ট-ইন আছে। 

প্রথমে আমরা ডাটা লেয়ার থেকে শুরু করবো। `docker run` কম্যান্ড ব্যবহার করে redis-এর একটি ইন্সট্যান্স রান করি। এক্ষেত্রে ব্যাকগ্রাউন্ডে কনটেইনারটি চালানোর জন্যে -d প্যারামিটার ব্যবহার করবো। কনটেইনারটির নাম দিব `redis`। 
এরপর আমরা PostgresSQL ডাটাবেজের একটি ইন্সট্যান্স রান করবো। কনটেইনারটির নাম দিব `db`। এরপর আমরা অ্যাপলিকেশন সার্ভিসগুলো চালু করবো। আমরা voting-app ইমেজের একটি ইন্সট্যান্স (vote) রান করার মাধ্যমে ভোটিং ইন্টারফেচের জন্য একটি ফ্রন্ট-ইন্ড অ্যাপ ডিপ্লয় করবো। যেহেতু এটি একটি ওয়েব সার্ভার তাই পোর্ট `80`-তে এর একটি ওয়েব UI ইন্সট্যান্স রানিং আছে। হোস্ট সিস্টেমে পোর্ট `5000`-এ এটি পাবলিশ করা হলো যাতে আমরা যেকোন ওয়েব ব্রাউজার থেকে ব্যবহার করতে পারি। এরপর আমরা রেজাল্ট ওয়েব অ্যাপলিকেশন ডিপ্লয় করবো যেটা ইউজারদের রেজাল্ট দেখাবে। এর জন্য আমরা result-app ইমেজ ব্যবহার করে একটি কনটেইনার ডিপ্লয় করবো যেটা পোর্ট `80`-তে থাকবে এবং হোস্ট সিস্টেমে পোর্ট `5001`-এ থাকবে। এইভাবে আমরা ব্রাউজার থেকে রেজাল্টিং অ্যাপের ওয়েব UI অ্যাক্সেস করতে পারবো। সবশেষে আমরা worker ইমেজ একটি ইন্সট্যান্স রান করে worker ডিপ্লয় করবো। 

![](Screenshot%20from%202022-05-14%2020-35-56.png)

এখন হোস্ট মেশিনে সবগুলো ইন্সট্যান্স রান করছে এবং সব কিছু ঠিকঠাক মনে হচ্ছে। কিন্তু এখানে কিছু সমস্যা আছে, এটা ঠিকঠাক কাজ করছে না। 

![](Screenshot%20from%202022-05-14%2019-53-08.png)

সমস্যাটা হলো আমরা সব কনটেইনার ঠিকঠাক রান করেছি কিন্তু একটা অন্যটার সাথে ঠিকঠাক লিংক করে দিই নি। যেমন আমরা ভোটিং ওয়েব অ্যাপলিকেশনকে একটি নির্দিষ্ট রেডিস ইন্সট্যান্স ব্যবহারের কথা বলে দিই নি। হোস্ট মেশিনে অনেকগুলো রেডিস ইন্সট্যান্স রানিং থাকতে পারে। আবার worker-কে নির্দিষ্ট postgressql ব্যবহারের কথাও বলে দেয়া হয় নি। আমরা এটা কীভাবে করবো!
এইখানে আমরা link ব্যবহার করবো। 

`link` হলো একটি কম্যান্ড লাইন অপশন যেটা দুটো কনটেইনারকে লিংক টুগেদার করতে ব্যবহৃত হয়। যেমন voting-app ওয়েব সার্ভিসটি redis সার্ভিসের উপর নির্ভরশীল। যখন ওয়েব সার্ভার চালু হয় তখন এটি হোস্টে একটি রেডিস সার্ভিসের খোঁজ করে। তাই যখন আমরা voting-app কনটেইনারটি রান করবো তখন link অপশন ব্যবহার করে একটি redis কনটেইনারের সাথে তা লিংক করে দিব। এক্ষেত্রে `docker run` কম্যান্ডের সাথে `--link` অপশন ব্যবহার করে redis কনটেইনারের নামটি স্পেসিফাই করে দিতে হবে (এখানে সেটা redis) এবং তারপরে কোলন দিয়ে হোস্টের নাম দিতে হবে যেটা voting-app খুঁজছে আর এক্ষেত্রে সেটি হলো redis। 

![](Screenshot%20from%202022-05-14%2019-54-18.png)

এর ফলে `voting-app` কনটেইনারে `/etc/hosts` নামে একটি ফাইল তৈরি হয় যেখানে redis কনটেইনারের একটি ইন্টারনাল আইপি সহ redis হোস্ট নামের একটি এন্ট্রি যুক্ত থাকে। 

![](Screenshot%20from%202022-05-14%2019-56-10.png)

ঠিক একইভাবে আমরা result-app এর সাথে ডাটাবেজের সংযুক্তির জন্যে link অপশন ব্যবহার করে db ডাটাবেজ লিংক্ড করে দিই। সবশেষে worker অ্যাপলিকেশনের redis এবং postgres ডাটাবেজ দুইটার সাথেই সংযুক্তির প্রয়োজন হয়। তাই আমরা worker কনটেইনার রান করার সময় দুইটা লিংক ব্যবহার করি। 

![](Screenshot%20from%202022-05-14%2019-57-59.png)

এইভাবে লিংক ব্যবহার করা অনুচিত এবং ভবিষ্যতে এটি বন্ধও হয়ে যেতে পারে। 

যাই হোক, যেহেতু আমরা ডকার রান কম্যান্ড ব্যবহার করে অ্যাপলিকেশন স্ট্যাক ইমপ্লিমেন্ট করেছি তাই এখান থেকে ডকার কম্পোজ ফাইল তৈরি করা সহজ হবে। 
প্রথমে আমরা কনটেইনারগুলোর নামের ডিকশনারি তৈরির মাধ্যমে শুরু করবো। docker run কম্যান্ডে আমরা যেসব কনটেইনার নাম ব্যবহার করেছি সেগুলোই এখানে ব্যবহার করবো। 

![](Screenshot%20from%202022-05-14%2019-58-59.png)

তারপর প্রত্যেক আইটেমের নিচে কোন ইমেজ ব্যবহার করা হইছে তা স্পেসিফাই করে দিব। 

![](Screenshot%20from%202022-05-14%2019-59-21.png)

এরপর দেখবো আর কী কী অপশন ব্যবহার করা হয়েছে। যেহেতু আমরা পোর্ট পাবলিশ করেছি তাই সেগুলো নির্দিষ্ট কনটেইনারের নিচে লিখতে হবে। এক্ষেত্রে আমরা একটি প্রোপার্টি তৈরি করবো ports নামে এবং তার নিচে সকল পোর্টগুলো লিখবো। 

![](Screenshot%20from%202022-05-14%2019-59-43.png)

সবশেষে লিংকগুলো যুক্ত করে দিব। 

![](Screenshot%20from%202022-05-14%2020-00-05.png)

তাহলে আমাদের ডকার কম্পোজ ফাইলের কাজ শেষ। এখন পুরো অ্যাপলিকেশন স্ট্যাক চালু করতে আমাদের docker-compose up কম্যান্ড ব্যবহার করতে হবে। 

আমরা ভোটিং অ্যাপলিকেশনের উদাহরণ দেখানোর সময় ধরে নিয়েছিলাম যে সব ইমেজ অলরেডি বিল্ড করা আছে। পাঁচটা ভিন্ন কম্পোনেন্টের মধ্যে দুইটা (redis ও postgres) অলরেডি ডকার হাবে অ্যাভেইলেবল আছে। কিন্তু বাকি তিনটা নিজস্ব বিল্ড করা। এগুলো ডকার রেজিস্ট্রিতে অ্যাভেইলেবল নয়। আমরা যদি চাই ডকার কম্পোজ ফাইলে কোন ইমেজ পুল না করে বিল্ড করার নির্দেশ দিব তাহলে সেটাও করা সম্ভব। এক্ষেত্রে আমাদের image key-এর জায়গায় build ব্যবহার করতে হবে এবং একটি ডিরেক্টরির লোকেশন স্পেসিফাই করে দিতে হবে যেখানে অ্যাপলিকেশন কোড ও ইমেজ তৈরির নির্দেশনাবলি দেওয়া আছে। 

![](Screenshot%20from%202022-05-14%2020-09-20.png)

আমরা এখন ডকার কম্পোজ ফাইলের বিভিন্ন ভার্সন সম্পর্কে জানবো। এটি অনেক গুরুত্বপূর্ণ কারণ আমরা বিভিন্ন জায়গায় বিভিন্ন ভার্সনের ডকার কম্পোজ ফাইল দেখতে পারি। 

ডকার কম্পোজ সময়ের সাথে সাথে ইভল্ভ করেছে এবং বর্তমানে এটি শুরুর দিকের তুলনায় অনেক বেশি অপশন সাপোর্ট করে। 

![](Screenshot%20from%202022-05-14%2020-48-31.png)

এটি হচ্ছে ডকার কম্পোজ ফাইলের অরিজিনাল ভার্সন যেটা ভার্সন ১.০ নামে পরিচিত। এটির কিছু প্রতিবন্ধকতা রয়েছে। যেমন : আমি যদি ডিফল্ট ব্রিজড নেটওয়ার্কের বাহিরে অন্য কোন নেটওয়ার্কে একটি কনটেইনার রান করতে চাই তাহলে সেটা স্পেসিফাই করার কোন অপশন এখানে নেই। আবার আমার যদি কোন ডিপেন্ডেন্সি থাকে (যেমন ভোটিং অ্যাপলিকেশন শুরু হওয়ার আগে অবশ্যই ডাটাবেজ কনটেইনার চালু হতে হবে) সেটি জানানোর কোন অপশন এখানে নেই। এজন্য ডকার কম্পোজ ফাইল ভার্সন ২.০ আসে। এর ফরমাট একটু আলাদা। 
এখানে স্ট্যাকের ইনফরমেশনগুলি সরাসরি স্পেসিফাই করা যায় না। সব ইনফরমেশন services সেকশনের অন্তর্ভুক্ত করতে হয়। 
আমাদের সুবিধামতো আমরা ভার্সন-১ বা ভার্সন-২ ব্যবহার করতে পারি। কিন্তু ডকার কম্পোজ কীভাবে বুঝবে আমি কোন ভার্সনের ফাইল ব্যবহার করছি? 
ভার্সন-২ বা তার পরের ভার্সনের ডকার কম্পোজ ফাইলের প্রথমেই ভার্সন নম্বর উল্লেখ করে দিতে হয়। 
আর একটা গুরুত্বপূর্ণ ভিন্নতা হলো নেটওয়ার্কিং। ভার্সন-১ এ ডকার কম্পোজ সকল কনটেইনারকে ডিফল্ট ব্রিজড নেটওয়ার্কে যুক্ত করে এবং তারপর লিংকের মাধ্যমে কনটেইনারের মধ্যে সম্পর্ক তৈরি করে। কিন্তু ভার্সন-২ তে ডকার কম্পোজ অ্যাপলিকেশনটির জন্যে একটি নতুন ব্রিজড নেটওয়ার্ক তৈরি করে এবং সকল কনটেইনারকে  ব্রিজড নেটওয়ার্কে যুক্ত করে। এভাবে সকল কনটেইনার নিজেদের সার্ভিস নাম ব্যবহার করে একে অন্যের সাথে কমিউনিকেট করতে পারে। অর্থাৎ ভার্সন-২ তে link ব্যবহার করার কোন প্রয়োজন নেই। ভার্সন-২ তে ডিপেন্ডেন্সি উল্লেখ করার অপশন আছে। যদি ভোটিং অ্যাপলিকেশনটি redis সার্ভিসের উপর নির্ভরশীল হয় তাহলে depends_on ব্যবহার করে তা বলে দিতে পারি। 

![](Screenshot%20from%202022-05-14%2020-10-46.png)

এরপর আসে সর্বশেষ ভার্সন যেটা হলো ভার্সন-৩। এটা অনেকটা ভার্সন-২ এর মতোই। সবার উপরে ভার্সন নম্বর উল্লেখ করে দিতে হবে এবং services সেকশনের আন্ডারে সব সার্ভিস অন্তর্ভুক্ত করতে হবে। ভার্সন-৩ তে Docker Swarm এর জন্য কাজ করা যায় যেটা সম্পর্কে আমরা পরবর্তীতে জানবো। 

![](Screenshot%20from%202022-05-14%2020-25-24.png)

এখন ডকার কম্পোজে নেটওয়ার্ক সম্পর্কে কিছু কথা বলি। 
আমরা আমাদের অ্যাপলিকেশন স্ট্যাকটির জন্য সকল কনটেইনার ডিফল্ট ব্রিজড নেটওয়ার্কেই রান করেছি। মনে করি আমরা বিভিন্ন সোর্স থেকে তৈরি হওয়া ট্রাফিক কন্টেইন করার জন্য এই আর্কিটেকচারটি মোডিফাই করবো। যেমন আমরা ইউজার থেকে আসা ট্রাফিক এবং অ্যাপলিকেশনের ইন্টারনাল ট্রাফিক আলাদা করতে চাই। এজন্য আমরা একটি ফ্রন্ট-ইন্ড নেটওয়ার্ক তৈরি করবো যেটা ইউজার ট্রাফিকের জন্য এবং একটি ব্যাক-ইন্ড নেটওয়ার্ক তৈরি করবো অ্যাপলিকেশনের অভ্যন্তরীণ ট্রাফিকের জন্য। তারপর আমরা ইউজার ফেসিং অ্যাপলিকেশনগুলো (voting-app, result-app) ফ্রন্ট-ইন্ড নেটওয়ার্কের সাথে যুক্ত করে দিব এবং বাকি কম্পোনেন্টগুলো ব্যাক-ইন্ড নেটওয়ার্কের সাথে যুক্ত করে দিব। 

![](Screenshot%20from%202022-05-14%2020-11-50.png)

এখন ডকার কম্পোজ ফাইলে এটি কীভাবে প্রকাশ করবো? 
এক্ষেত্রে ফাইলের একদম শেষে `networks` নামে একটি property দিয়ে তার আন্ডারে সব নেটওয়ার্ক উল্লেখ করে দিতে হবে (এক্ষেত্রে দুটি নেটওয়ার্ক - ফ্রন্ট-ইন্ড ও ব্যাক-ইন্ড)। তারপর প্রত্যেকটি সার্ভিসের আন্ডারে `networks` নামে প্রোপার্টি দিয়ে তার আন্ডারে সার্ভিসটি যেসব নেটওয়ার্কের সাথে যুক্ত তা উল্লেখ করে দিতে হবে। এক্ষেত্রে redis,worker এবং db-এর জন্যে শুধুমাত্র ব্যাক-ইন্ড নেটওয়ার্ক এবং voting-app ও result-app এর ক্ষেত্রে ফ্রন্ট-ইন্ড ও ব্যাক-ইন্ড উভয় নেটওয়ার্ক।

![](Screenshot%20from%202022-05-14%2020-12-14.png)
