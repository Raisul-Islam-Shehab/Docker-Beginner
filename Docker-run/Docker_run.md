এখন আমরা আরো অন্যান্য "Docker Commands" এর সাথে পরিচিত হবো। আমরা ইতিমধ্যেই জেনেছি যে নিম্নোক্ত কমান্ডটি রান করার মাধ্যমে আমরা একটি কন্টেইনারের মধ্যে **redis** সার্ভিসটি চালাতে পারি এবং সেক্ষেত্রে **redis** এর সবথেকে লেটেস্ট ভার্সনটা নিজে থেকেই চলে আসবে।

``` docker run redis ```

কিন্তু এমন যদি হয় যে আমরা **redis** সার্ভিসটার একটা পুরোনো ভার্সন রান করাতে চাচ্ছি, সেক্ষেত্রে করণীয় কি!

ব্যাপারটা একদমই সহজ। সেক্ষেত্রে শুধু আমাদের **redis** এর পর একটি কোলন ( : ) যোগ করে তারপরেই আমাদের কাঙিখত ভার্সন নম্বর টা দিয়ে দিতে হবে।

``` docker run redis:4.0 ```

এই ভার্সন ঠিক করে দেয়াটা হলো একটি **Tag** যোগ করা। যদি আমরা কোনো **Tag** যোগ না করি তাহলে কমান্ড রান করার পরেই দেখতে পাবো যে কমান্ডটি নিজে থেকেই **latest** নামক ট্যাগটি ব্যাবহার করবে এবং সর্বশেষ ভার্সনটি ডিফল্ট হিসেবে রান করবে।

![latest](/Docker-run/latest.png)

এখন একজন ইউজার হিসেবে কিভাবে আমরা এসব ভার্সন সম্পর্কে জানতে পারব? এর জন্য রয়েছে **[dockerhub.com](https://hub.docker.com/search?q=)**, যেখান থেকে কোনো ইমেজ খুঁজে বের করলেই এর সাথে সকল সাপোর্টেড ট্যাগ, ইমেজটার ডেসক্রিপশনে পেয়ে যাবো। এখানে প্রত্যেক ভার্সনেরই ছোট বড় সবধরনের ট্যাগ লিস্ট করা থাকে।

![versions](/Docker-run/versions.png)

এখন আমরা ইনপুট নেয়ার ব্যাপারে কিছু কথা বলব... 
---

ধরি, আমাদের এমন একটা **Prompt Application** আছে যেটা রান করা হলে একটা নাম চেয়ে থাকে এবং নাম ইনপুট করা হলে সাথে সাথে একটা ওয়েলকাম ম্যাসেজ দেখায়।

![prompt application](/Docker-run/prompt%20app.png)

এখন যদি এই এপ্লিকেশনটা কে আমরা **Dockerize** করি এবং এটাকে একটি **Docker container** হিসেবে রান করতে যাই, তাহলে দেখতে পাবো যে এখানে আমাদের থেকে ইনপুট নেয়ার কোনো অপশনই দিচ্ছে না। বরং আমাদের যে লেখাটা আউটপুট আসার কথা, সেটা সরাসরি প্রিন্ট করে দিচ্ছে।

![no input](/Docker-run/no%20input.png)

এটার কারণ হচ্ছে, ডিফল্ট হিসেবে কোনো **Docker container** কোনো প্রকার ইউজার ইনপুটের অপেক্ষা করে না। যদিও আমরা এটার কনসোলের সাথে যুক্ত আছি তারপরও এটার কোনো টার্মিনাল না থাকায় ইনপুট গ্রহন করতে পারে না। এভাবে রান হওয়াকে বলা হয় "Non Interactive Mode". Docker সাধারণত এই মোডেই ডিফল্ট হিসেবে রান হয়ে থাকে।

এরপরও যদি আমরা Container-এ ইনপুট নিতে চাই তাহলে আমাদেরকে আমাদের হোস্টের স্ট্যান্ডার্ড ইনপুটটাকে Docker container এ ম্যাপ করে দিতে হবে -i প্যারামিটারটি দ্বারা।

``` docker run -i kodekloud/simple-prompt-docker ```

এই -i প্যারামিটারটি আমাদেরকে "Interactive Mode" এ যাওয়ার সুযোগ করে দেয়।

এবার লক্ষ্য করলে করলে দেখা যাবে আমরা যদি নতুন কমান্ডটি রান করি তাহলে আমাদের থেকে ইনপুট নিয়ে এক্সপেকটেড আউটপুটটি প্রিন্ট হচ্ছে।

![input](/Docker-run//input.png)

কিন্তু এখানে এখনো কিছু বাদ যাচ্ছে। আমরা যখন Docker container হিসেবে রান না করে এপ্লিকেশন টা সরাসরি Promt এ রান করেছিলাম তখন আমাদের থেকে নাম ইনপুট চেয়ে একটা লেখা এসেছিল যেটা এখনো Container হিসেবে রান করার সময় আসেনি। কারণটা হলো, ইনপুট নেয়ার কথা টা এসেছিল টার্মিনালে। কিন্তু আমরা আমাদের Docker container এ টার্মিনাল যোগ করিনি। সুতরাং এটার ইনপুট চেয়ে লেখাটা প্রিন্ট করার কোনো সুযোগ নেই। যদি আমরা এখানে -t ট্যাগটি যোগ করে আবার Docker কমান্ডটি লিখে ইনপুট দেই তাহলে Container টি টার্মিনাল পেয়ে যাবে, কারণ -t প্যারামিটারটি "sudo terminal" কে ইঙ্গিত করে।

``` docker run -it kodekloud/simple-prompt-docker ```

সুতরাং এখন যেহেতু আমাদের কমান্ডে একসাথে -i ও -t প্যারামিটার দুটি আছে, সেহেতু আমাদের Container এ আমরা এখন "Interactive Mode" ও টার্মিনালে যুক্ত আছি।

![input & terminal](/Docker-run/input%20%26%20terminal.png)

এবারে আমরা পরিচিত হবো Container এ "Port mapping" অথবা "Port publishing" এর সাথে...
---

আমরা আবার একটু ফিরে যাই যেখানে আমরা একটা সাধারণ ওয়েব এপ্লিকেশন একটা Docker container এর ভেতরে রেখেছিলাম আমার Docker host এ। মনে রাখা জরুরি যে, যে হোস্টে Docker ইন্সটল করা আছে সেটাই আমাদের **Docker host** বা **Docker engine**. 
যখন আমরা Container এ কোনো ওয়েব এপ্লিকেশন রান করব তখন এটি চলবে এবং আমরা দেখতে পাবো যে সার্ভারও রানিং অবস্থায় আছে।

কিন্তু একজন বাইরের ইউজার কিভাবে এপ্লিকেশনটাতে একসেস পাবে? নিম্নোক্ত ছবিটি দেখলে বোঝা যাচ্ছে যে আমার এপ্লিকেশনটা Port:5000 এ চলছে।

![server](/Docker-run/server.png)

তার মানে আমি উক্ত পোর্ট থেকে আমার এপ্লিকেশন এর একসেস পেতে পারব। পোর্ট তো জানলাম, কিন্তু কোনো ব্রাউজারে কোন IP address থেকে থেকে আমরা এই এপ্লিকেশনের একসেস পাবো!

এই কাজটা আমরা ২ ভাবে করতে পারি-

1. আমরা আমাদের Docker container এর IP ব্যাবহার করতে পারি। ডিফল্ট হিসেবে প্রত্যেক Container কে একটা IP address দেয়া হয়ে থাকে। এই কন্টেইনারের ক্ষেত্রে সেটা হল ***172.17.0.2***। কিন্তু এই IP টি শুধু আমরা এই Docker host এর ভেতর থেকেই একসেস করতে পারব। তাই একে বলা হয় **Internal IP**. যদি আমরা এই Docker host এর ভেতরেই কোনো ব্রাউজার খুলি এবং **http://172.17.0.2:5000** লিখে সার্চ দেই তাহলে আমরা ওয়েব এপ্লিকেশনটিকে পেয়ে যাবো। একই IP ব্যাবহার করে বাইরের কেও কিন্তু এই এপ্লিকেশন পাবে না যেহেতু এটা একটা Internal IP.
2. বাইরের কেও এই এপ্লিকেশন একসেস করতে হলে আমরা সেক্ষেত্রে আমাদের Docker host এর IP ব্যাবহার করতে পারি। এখানে আমাদের হোস্টের IP address হলো **192.168.1.5**. কিন্তু এর মাধ্যমে একসেস পেতে হলে আমাদেরকে আগে Container এর পোর্ট টিকে হোস্ট IP এর কোনো ফ্রি পোর্টের সাথে ম্যাপ করে দিতে হবে।

উদাহরণ হিসেবে এই এপ্লিকেশনটি যদি আমরা হোস্টের Port:80 তে পেতে চাই তাহলে Container এর Port:5000 এর সাথে এর ম্যাপিং করে দিতে হবে -p প্যারামিটারটি ব্যাবহার করে।

``` docker run –p 80:5000 kodekloud/simple-webapp ```

সুতরাং বাইরের যেকোনো ইউজার এখন চাইলেই **http://192.168.1.5:80** URL এ যেয়ে এপ্লিকেশনটি দেখতে পাবে। এখানে **Port:80** এর সব ট্রাফিক ***Routed*** হয়ে পৌঁছে যাবে Container এর **Port:5000** এ।

এই পদ্ধতিতে আমরা একই এপ্লিকেশনের অনেকগুলো ইন্সট্যান্স তৈরি করে সেগুলো হোস্টের ভিন্ন ভিন্ন পোর্টে ম্যাপ করে দিতে পারি অথবা ভিন্ন ভিন্ন এপ্লিকেশন ভিন্ন ভিন্ন পোর্টে রান করতে পারি।

``` 
    docker run –p 8000:5000 kodekloud/simple-webapp
    docker run –p 8001:5000 kodekloud/simple-webapp
    docker run –p 3306:3306 mysql
    docker run –p 8306:3306 mysql 
```

এটা খেয়াল রাখতে হবে যে, একই পোর্টে কিন্তু একের অধিক কোনো ম্যাপিং করা যায় না।

![same port](/Docker-run/same%20port.png)

![full process](/Docker-run/full%20process.png)
