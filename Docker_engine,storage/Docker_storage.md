এই পর্যায়ে আমরা Docker এর স্টোরেজ ড্রাইভার ও স্টোরেজ সম্পর্কে জানব। আমরা জানব Docker কিভাবে ডাটা স্টোর এবং Container এর ফাইল সিস্টেম ব্যবস্থাপনা করে থাকে।
---

শুরুতেই দেখব Docker কিভাবে লোকাল ফাইল সিস্টেমে ডাটা স্টোর করে। যখনই আমরা Docker ইন্সটল করছি তখনই একটা ফোল্ডার স্ট্রাকচার তৈরি হয়েছে ```/var/lib/docker``` এ। এর মধ্যে ```aufs```, ```containers```, `image` ইত্যাদি ফোল্ডার রয়েছে যাতে Docker সম্পর্কিত ডাটা সংরক্ষিত হয়। যেমন, `container` ফোল্ডারে সকল তৈরিকৃত Container গুলোর ডাটা থাকে, আবার image ফোল্ডারে সকল Image স্টোর করা থাকে।

![file](/Docker_engine%2Cstorage/file.png)

প্রশ্ন আসে, Docker কিভাবে Containers ও Image সম্পর্কিত ডাটা স্টোর করে থাকে?
---
এটা জানার আগে আমাদের Docker এর `Layered architecture` বুঝতে হবে। যখনই Docker কোনো Image তৈরি করে তখন তা `Layered architecture` এ তৈরি করে থাকে। `dockerfile` এর প্রত্যেকটা লাইন Image এ নতুন লেয়ার সৃষ্টি করে, শুধু আগের লেয়ারের সাথে পার্থক্যের উপর ভিত্তি করে।

নিচের উদাহরণটি দেখলে বোঝা যায়, প্রদত্ত `dockerfile` এ সর্বপ্রথম ইন্সট্রাকশনে বেইজ `ubuntu OS` থেকে প্রথম লেয়ার শুরু হয়। পরের ধাপে `apt packages` ইন্সটল করার লেয়ার তৈরি হয়, তারপরের লেয়ার তৈরি হয় `python packages` এর জন্য, এরপর `সোর্স কোড` কপি করে দেয়ার লেয়ার এবং সবশেষ লেয়ারে Image এর `Entrypoint` আপডেট করে দেয়া হবে।

![df1](/Docker_engine%2Cstorage/df1.png)

প্রত্যেক লেয়ারে যে আগের লেয়ারের পরিবর্তনের পর থেকে হিসাব করা হয় তা প্রত্যেক লেয়ারের সাইজ দেখলেই বোঝা যায়। যেমন, এখানে `ubuntu` বেইস image এর সাইজ `120MB`, এরপর পরবর্তী `apt packages` এর সাইজ `306MB` এবং এর পরবর্তী লেয়ার গুলো খুবই কম জায়গা নিয়েছে। 

![df1build](/Docker_engine%2Cstorage/df1build.png)

`Layered architecture` এর সুবিধা বোঝার জন্য আমরা আরো একটা `dockerfile` চিন্তা করি যেখানে প্রথম ৩ টি ইন্সট্রাকশন হুবহু প্রথমটার মতো কিন্তু এই ক্ষেত্রে ভিন্ন একটি সোর্স কোড ও `Entrypoint` ব্যবহার করা হয়েছে। এখন যদি আমরা `docker build` কমান্ড ব্যবহার করে এই এপ্লিকেশনের আরেকটি image তৈরি করতে চাই, তাহলে দেখা যাবে যে, যেহেতু আগের এবং এই এপ্লিকেশনের `dockerfile` এর প্রথম ৩ টি লেয়ার একই কাজ করে এবং আগেই তৈরি করা হয়েছিল, সেহেতু Docker আর এই ৩ টি লেয়ার নতুন করে তৈরি করবে না। বরং Cache থেকে আগের ৩ টি লেয়ার নিয়ে শুধু পরবর্তী ২ লেয়ার অর্থাৎ `সোর্সকোড` ও `Entrypoint` আপডেট করার লেয়ার তৈরি করবে। এই পদ্ধতিতেই Docker দ্রুত ও সহজে Images তৈরি করে থাকে এবং স্টোরেজ বাচিয়ে দেয়।

একই কাজ যখন আমরা কোনো dockerfile আপডেট করি তখনও হয়ে থাকে।

![df2](/Docker_engine%2Cstorage/df2.png)

একবার `dockerfile` থেকে বিল্ড হয়ে গেলে সেটা `read only` হয়ে যায় এবং পুনরায় বিল্ড করা ছাড়া পরিবর্তনের কোনো উপায় নেই। যখন আমরা `docker run` কমান্ড ব্যবহার করে container তৈরি করি তখন  Docker এই Image লেয়ারের উপর একটি নতুন `Read Write` লেয়ার তৈরি করে। এই লেয়ারটি ব্যবহৃত হয় container এ উৎপন্ন ডাটা স্টোর করার জন্য। যদি আমরা কোনো কারণে container টি ডিলেট করে ফেলি তাহলে এর মধ্যে থাকা সকল ডাটাও ডিলেট হয়ে যাবে।

![layer1](/Docker_engine%2Cstorage/layer1.png)

একটি Image থেকে আমরা যত containers তৈরি করব তার সবই Image টির বৈশিষ্ট্যগুলো শেয়ার করবে। Image এর কোনো বিষয়ই container সরাসরি পরিবর্তন-পরিবর্ধন করতে পারবে না। চাইলে Image এর কোনো ফাইলের একটি কপি `Read Write` লেয়ারে এ এনে তাতে ইচ্ছেমতো পরিবর্তন আনতে পারবে। এটাকে বলা হয় `Copy-On-Write` মেকানিজম। 

![copy](/Docker_engine%2Cstorage/copy.png)

আমরা যদি কোনো Container এর ভেতরের ডাটা পারমানেন্ট ভাবে সংরক্ষণ করতে চাই অর্থাৎ Container টি ডিলেট করার পরেও ডাটা গুলো রাখতে চাই, তখন আমরা কি করব?
---

এক্ষেত্রে আমরা একটি স্থায়ী ভলিউম তৈরি করে নিতে পারি। ভলিউম তৈরি করতে নিচের কমান্ড টি রান করলে `/var/lib/docker/volumes` এর ভেতর `data_volume` নামের ফোল্ডার তৈরি হয়ে যাবে।

`docker volume create data_volume`

পরবর্তীতে আমরা `-v` অপশনটি ব্যাবহার করে উদাহরণ স্বরূপ একটি `mysql Container` এর `Read Write` লেয়ারে ডাটাবেজের ডিফল্ট স্টোরেজ এর সাথে আমাদের `data_volume` ফোল্ডার ম্যাপ করে দিতে পারি। এই বিষয়টি আমরা আগেও **["Docker run"](/Docker-run/Docker_run.md)** সেকশনে দেখে এসেছি। একে বলে `Volume mounting`.

`docker run –v data_volume:/var/lib/mysql mysql`

যদি আমরা `/var/lib/docker/volumes` এর বাইরে কম্পিউটারের অন্য কোথাও থেকে ডাটা আনতে চাই বা রাখতে চাই তাহলে সেক্ষেত্রে শুধু ডাটার পুরো `path` টা লিখে দিতে হবে কমান্ডে। একে `Bind mounting` বলা হয়।

`docker run –v /data/mysql:/var/lib/mysql mysql`

`-v` অপশনটা ব্যবহার করা অনেকটা পুরোনো সিস্টেম। তার বদলে এখন `--mount` প্যারামিটারটা ব্যবহৃত হয়, কেননা এটিতে সবকিছু আরো বেশি পরিষ্কার ভাবে উল্লেখ থাকে। উদাহরণ হিসেবে আমরা আগের কমান্ডটাই `--mount` ব্যবহার করে লিখলে এমনটা হবে-

`
docker run \ 
–-mount type=bind,source=/data/mysql,target=/var/lib/mysql mysql
`

এখানে `type` দিয়ে এটা কেমন `mounting` হবে সেটা বোঝায় আর বাকি গুলো নাম দেখেই বোঝা যাচ্ছে।

এখন পর্যন্ত এই রিডিং এ আমরা যা যা দেখলাম তা ম্যানেজ করার কাজ হচ্ছে স্টোরেজ ড্রাইভারের। এরকম কয়েকটি স্টোরেজ ড্রাইভার হলো-

* AUFS
* ZFS
* BTRFS
* Device Mapper
* Overlay
* Overlay2

কোন ড্রাইভার ব্যবহৃত হবে তা নির্ভর করে আমরা কোন `OS` চালাচ্ছি তার উপর। যেমন, `Ubuntu OS` এ ডিফল্ট ড্রাইভার হলো `AUFS`. যা অন্য গুলোতে একই না। এটা অটোমেটিক ভাবে নির্ণয় হয়ে থাকে।